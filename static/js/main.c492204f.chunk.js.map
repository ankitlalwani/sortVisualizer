{"version":3,"sources":["logo.svg","Home.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","Home","props","getChartData","data1","labels","datasets","label","data","backgroundColor","slideValue","state","console","log","i","randomNumber","Math","ceil","random","setState","mergeSort","slicedArray","slice","mergeSortSlice","length","handleSliderEvent","event","a","slideValue1","sleepTime","itemsRendered","maxValue","slidebgColor","type","options","legend","display","scales","yAxes","ticks","beginAtZero","autoskip","xAxes","bind","quickSort","partition","ClickQuickSort","ClickBubbleSort","bubbleSort","ClickHeapSort","heapSort","heap_root","this","array","leftIndex","rightIndex","midValue","round","j","sleep","tempArray","splice","values","Promise","resolve","setTimeout","unsortedArray","items","left","right","index","x","temp","input","array_length","floor","max","defaults","global","animation","value","Container","style","textAlign","fontFamily","alignItems","paddingBottom","color","fontSize","className","height","paddingLeft","Slider","defaultValue","vertical","progress","min","onChange","position","width","redraw","paddingTop","onClick","React","Component","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.c492204f.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","import React, { useState, useEffect } from 'react';\nimport {Bar} from 'react-chartjs-2';\nimport {Doughnut} from 'react-chartjs-2';\nimport { defaults } from 'react-chartjs-2';\nimport ReactSlider from 'react-slider'\nimport { VerticalRangeSlider } from \"vertical-slider\";\nimport { Slider, RangeSlider, Row, Col, Container } from 'rsuite';\nimport 'rsuite/lib/styles/index.less';\nimport 'rsuite/dist/styles/rsuite-default.css';\nimport { wait } from '@testing-library/react';\nimport './Home.css'\n\n\nclass Home extends React.Component {\n\n     \n    constructor(props){\n        super(props);\n        this.state={\n            sleepTime: 0,\n            itemsRendered: 0,\n            maxValue:200,\n            slideValue: 100,\n            slidebgColor: \"47CF8E\",\n            type: 'bar',\n            data: {\n                labels: [0,1],\n                datasets: [{\n                    label: '',\n                    data: [0,1],\n                    backgroundColor: [\n                        'rgba(255, 99, 132, 0.2)'\n                        \n                    ]\n                    \n                }]\n            },\n            options: {\n                legend: {\n                    display: false\n\n                },\n                scales: {\n                    yAxes: [{\n                        display: false,\n                        ticks: {\n                            beginAtZero: true,\n                            autoskip: true\n                        }\n                    }],\n                    xAxes: [{\n                        display: false\n                    }]\n                }\n            }\n\n        }\n        this.handleSliderEvent = this.handleSliderEvent.bind(this);\n        this.mergeSortSlice=this.mergeSortSlice.bind(this);\n        this.quickSort = this.quickSort.bind(this);\n        this.partition = this.partition.bind(this);\n        this.ClickQuickSort=this.ClickQuickSort.bind(this);\n        this.ClickBubbleSort=this.ClickBubbleSort.bind(this);\n        this.bubbleSort=this.bubbleSort.bind(this);\n        this.ClickHeapSort=this.ClickHeapSort.bind(this);\n        this.heapSort=this.heapSort.bind(this);\n        this.heap_root=this.heap_root.bind(this);\n    }\n\n\n    componentDidMount(){\n        this.getChartData();\n        console.log(\"inside component did mount\");\n    }\n\n    getChartData=()=>{\n        \n       let data1= {\n            labels: [0,1],\n            datasets: [{\n                label: '',\n                data: [0,1],\n                backgroundColor: [\n                    'rgba(255, 99, 132, 0.2)'\n                    \n                ]\n                \n            }]\n        }\n        const slideValue = this.state.slideValue;\n        const backColor= [\"pink\", \"purple\", \"blue\", \"green\", \"lightblue\", \"neon\", \"red\", \"lightgreen\", \"yellow\", \"grey\", \"lightgrey\", \"orange\"]\n        \n        console.log(\"data1 \", data1);\n        console.log(\"inside getCharData\");\n\n        for(let i=0;i<slideValue;i++){\n            const randomNumber = Math.ceil(Math.random() * slideValue);\n\n            data1.labels[i]=randomNumber;\n            data1.datasets[0].data[i]=randomNumber;\n            data1.datasets[0].backgroundColor[i]=\"lightblue\";\n        }\n        \n        this.setState({\n            data: data1\n        })\n\n    }\n\n\n    //parent merge sort call\n      mergeSort=()=> {\n\n        const data1 = this.state.data;\n        let unsortedArray = data1.datasets[0].data;\n        // create copy of the array \n       let slicedArray = unsortedArray.slice()\n        // asynchronous sort the copy\n        this.mergeSortSlice(slicedArray, 0, slicedArray.length);\n        return;\n    }\n\n    //recursive merge sort calls for sorting the arrays\n    async mergeSortSlice(array, leftIndex, rightIndex) {\n        if (rightIndex-leftIndex <= 1)\n            return;\n        \n        let midValue = Math.round((rightIndex+leftIndex) / 2);\n    \n        // perform recursions\n        await this.mergeSortSlice(array, leftIndex, midValue);\n        await this.mergeSortSlice(array, midValue, rightIndex);\n    \n         // Merge the values in the same array and shift others.\n        let i = leftIndex, j = midValue;\n        while (i < rightIndex && j < rightIndex) {\n            let data1 = this.state.data;\n            let sleepTime = this.state.sleepTime;\n            const slideValue = this.state.slideValue;\n\n            if(slideValue<=10){\n                sleepTime=400;\n            }else if(slideValue>10&&slideValue<=30){\n                sleepTime=300;\n            }\n            else if(slideValue>30&&slideValue<=50){\n                sleepTime=200;\n            }else if(slideValue>50&&slideValue<=99){\n                sleepTime=100;\n            }else if(slideValue>99&&slideValue<=150){\n                sleepTime=50;\n            }\n            else{\n                sleepTime=20;\n            }\n            await this.sleep(sleepTime);\n            \n            data1.datasets[0].backgroundColor[i]=\"purple\";\n            data1.datasets[0].backgroundColor[j]=\"purple\";\n            this.setState({data: data1});\n\n            await this.sleep(sleepTime);\n\n            if (array[i] > array[j]) {\n                let tempArray = array[j]; \n                array.splice(j, 1); array.splice(i, 0, tempArray);\n                j ++;\n            }\n            i ++;\n            if (i==j) j ++;\n    \n            // copy back the current state of the sorting\n           let values = array.slice();\n           console.log(\"values inside mergesortsplice :\", values);\n           \n           for(let i=0;i<array.length;i++){\n            data1.datasets[0].backgroundColor[i]=\"lightblue\";\n        }\n\n            // slow down\n            await this.sleep(sleepTime);\n\n            console.log(\"checking for sleep fn\")\n\n            \n                data1.datasets[0].data=values;\n                data1.labels=values;\n                \n            this.setState({data: data1});\n\n        }\n    }\n\n    //sleep for the mentioned sleep time\n    async sleep(sleepTime) {\n        return new Promise(resolve => setTimeout(resolve, sleepTime));\n    }\n    \n\n    //parent Quick sort call\nasync ClickQuickSort(){\n\n        const data1 = this.state.data;\n        let unsortedArray = data1.datasets[0].data;\n        // create copy of the array \n       \n    await  this.quickSort(unsortedArray, 0, unsortedArray.length-1);\n\n     /*  data1.datasets[0].data = sortedArray;\n\n       this.setState({\n           data: data1\n       });*/\n    }\n\n    //recursive quick sort calls\n  async  quickSort(items, left, right) {\n        if(left<right){\n          let index = await this.partition(items, left, right);\n            await this.quickSort(items, left, index - 1);\n            await this.quickSort(items, index+1, right);\n        }\n    }\n\nasync  partition(items, left, right) {\n\n        let data1 = this.state.data;\n            let sleepTime = this.state.sleepTime;\n            const slideValue = this.state.slideValue;\n\n            if(slideValue<=10){\n                sleepTime=400;\n            }else if(slideValue>10&&slideValue<=30){\n                sleepTime=300;\n            }\n            else if(slideValue>30&&slideValue<=50){\n                sleepTime=200;\n            }else if(slideValue>50&&slideValue<=99){\n                sleepTime=100;\n            }else if(slideValue>99&&slideValue<=150){\n                sleepTime=50;\n            }\n            else{\n                sleepTime=20;\n            }\n            await this.sleep(sleepTime);\n        \n        let x=items[right];\n        let i=left -1;\n\n        for(let j=left; j<right;j++){\n            if(items[j]<=x){\n                i++;\n                let temp = items[i];\n                items[i] = items[j];\n                items[j] = temp;\n\n                data1.datasets[0].backgroundColor[i]=\"purple\";\n                data1.datasets[0].backgroundColor[right]=\"purple\";\n                this.setState({data: data1});\n\n                await this.sleep(sleepTime);\n\n                for(let i=0;i<items.length;i++){\n                    data1.datasets[0].backgroundColor[i]=\"lightblue\";\n                }\n        \n                    // slow down\n                    await this.sleep(sleepTime);\n                    \n                        data1.datasets[0].data=items;\n                        data1.labels=items;\n                        \n                    this.setState({data: data1});\n            }\n        }\n        i++;\n\n        let temp = items[i];\n            items[i] = items[right];\n            items[right] = temp;\n\n            data1.datasets[0].backgroundColor[i]=\"purple\";\n            data1.datasets[0].backgroundColor[right]=\"purple\";\n            this.setState({data: data1});\n\n            await this.sleep(sleepTime);\n\n            for(let i=0;i<items.length;i++){\n                data1.datasets[0].backgroundColor[i]=\"lightblue\";\n            }\n    \n                // slow down\n                await this.sleep(sleepTime);\n    \n                console.log(\"checking for sleep fn\")\n    \n                \n                    data1.datasets[0].data=items;\n                    data1.labels=items;\n                    \n                this.setState({data: data1});\n\n        return i;    \n        }\n        \n//click bubble sort\nasync ClickBubbleSort(){\n\n    const data1 = this.state.data;\n    let unsortedArray = data1.datasets[0].data;\n    // create copy of the array \n   \n    await this.bubbleSort(unsortedArray);\n\n   data1.datasets[0].data = unsortedArray;\n\n   this.setState({\n       data: data1\n   });\n}\n\nasync  bubbleSort(unsortedArray){\n\n    let data1 = this.state.data;\n            let sleepTime = this.state.sleepTime;\n            const slideValue = this.state.slideValue;\n\n            if(slideValue<=10){\n                sleepTime=400;\n            }else if(slideValue>10&&slideValue<=30){\n                sleepTime=300;\n            }\n            else if(slideValue>30&&slideValue<=50){\n                sleepTime=200;\n            }else if(slideValue>50&&slideValue<=99){\n                sleepTime=100;\n            }else if(slideValue>99&&slideValue<=150){\n                sleepTime=50;\n            }\n            else{\n                sleepTime=20;\n            }\n            await this.sleep(sleepTime);\n\n    for(let i=0; i<unsortedArray.length;i++){\n        for(let j=0;j<unsortedArray.length;j++){\n            if(unsortedArray[j]>unsortedArray[j+1]){\n                let temp = unsortedArray[j];\n                unsortedArray[j]=unsortedArray[j+1];\n                unsortedArray[j+1]=temp;\n\n                data1.datasets[0].backgroundColor[j]=\"purple\";\n                data1.datasets[0].backgroundColor[j+1]=\"purple\";\n                this.setState({data: data1});\n\n                await this.sleep(sleepTime);\n\n                for(let i=0;i<unsortedArray.length;i++){\n                    data1.datasets[0].backgroundColor[i]=\"lightblue\";\n                }\n                    // slow down\n                    await this.sleep(sleepTime);\n                    \n                        data1.datasets[0].data=unsortedArray;\n                        data1.labels=unsortedArray;\n                        \n                    this.setState({data: data1});\n\n                   // await this.sleep(sleepTime);\n\n            }\n        }\n    }\n}\n\n\n\n\n//click heap sort\nasync ClickHeapSort(){\n\n    const data1 = this.state.data;\n    let unsortedArray = data1.datasets[0].data;\n    // create copy of the array \n   \n    await this.heapSort(unsortedArray);\n\n   data1.datasets[0].data = unsortedArray;\n\n   this.setState({\n       data: data1\n   });\n}\n\n\n\nasync heapSort(input) {\n    let data1 = this.state.data;\n            let sleepTime = this.state.sleepTime;\n            const slideValue = this.state.slideValue;\n\n            if(slideValue<=10){\n                sleepTime=400;\n            }else if(slideValue>10&&slideValue<=30){\n                sleepTime=300;\n            }\n            else if(slideValue>30&&slideValue<=50){\n                sleepTime=200;\n            }else if(slideValue>50&&slideValue<=99){\n                sleepTime=100;\n            }else if(slideValue>99&&slideValue<=150){\n                sleepTime=50;\n            }\n            else{\n                sleepTime=20;\n            }\n            await this.sleep(sleepTime);\n    \n   let array_length = input.length;\n\n    for (let i = Math.floor(array_length / 2); i >= 0; i -= 1)      {\n       await this.heap_root(input, i,array_length);\n      }\n\n    for (let i = input.length - 1; i > 0; i--) {\n        //swapping\n        let temp = input[0];\n        input[0] = input[i];\n        input[i] = temp;\n        array_length--;\n\n            data1.datasets[0].backgroundColor[0]=\"purple\";\n                data1.datasets[0].backgroundColor[i]=\"purple\";\n                this.setState({data: data1});\n\n                await this.sleep(sleepTime);\n\n                for(let i=0;i<input.length;i++){\n                    data1.datasets[0].backgroundColor[i]=\"lightblue\";\n                }\n                    // slow down\n                    await this.sleep(sleepTime);\n                    \n                        data1.datasets[0].data=input;\n                        data1.labels=input;\n                        \n                    this.setState({data: data1});\n\n                   // await this.sleep(sleepTime);\n\n\n      \n      \n      await  this.heap_root(input, 0, array_length);\n    }\n}\n\n\n\nasync heap_root(input, i, array_length) {\n    let left = 2 * i + 1;\n    let right = 2 * i + 2;\n    let max = i;\n    \n    let data1 = this.state.data;\n            let sleepTime = this.state.sleepTime;\n            const slideValue = this.state.slideValue;\n\n            if(slideValue<=10){\n                sleepTime=400;\n            }else if(slideValue>10&&slideValue<=30){\n                sleepTime=300;\n            }\n            else if(slideValue>30&&slideValue<=50){\n                sleepTime=200;\n            }else if(slideValue>50&&slideValue<=99){\n                sleepTime=100;\n            }else if(slideValue>99&&slideValue<=150){\n                sleepTime=50;\n            }\n            else{\n                sleepTime=20;\n            }\n            await this.sleep(sleepTime);\n\n    if (left < array_length && input[left] > input[max]) {\n        max = left;\n    }\n\n    if (right < array_length && input[right] > input[max])     {\n        max = right;\n    }\n\n    if (max != i) {\n        //swapping\n        let temp = input[i];\n        input[i] = input[max];\n        input[max] = temp;\n\n        data1.datasets[0].backgroundColor[i]=\"purple\";\n        data1.datasets[0].backgroundColor[max]=\"purple\";\n        this.setState({data: data1});\n\n        await this.sleep(sleepTime);\n\n        for(let i=0;i<input.length;i++){\n            data1.datasets[0].backgroundColor[i]=\"lightblue\";\n        }\n            // slow down\n            await this.sleep(sleepTime);\n            \n                data1.datasets[0].data=input;\n                data1.labels=input;\n                \n            this.setState({data: data1});\n\n           // await this.sleep(sleepTime);\n\n      await this.heap_root(input, max,array_length);\n    }\n}\n\n\n    //update chart based on the slider value chosen.\n    handleSliderEvent = async (event) => {\n        let slideValue1 = event;\n        \n    \n        console.log(\"slideValue :\", slideValue1)\n    \n        this.setState({\n            slideValue: slideValue1\n        });\n        \n        this.getChartData();\n        console.log(this.state.slideValue);\n        \n    };\n\n    render() {\n        defaults.global.animation = false;\n        const type = this.state.type;\n        const options = this.state.options;\n        const maxValue = this.state.maxValue;\n        const data = this.state.data;\n        const slideValue = this.state.slideValue;\n        const value = this.state.value;\n\n        console.log(\"data: \", data);\n        console.log(\"type: \", type);\n        console.log(\"options: \", options);\n        console.log(\"SlideValue:\", slideValue)\n\n\n        return (\n            console.log(\"data2: \", data),\n            console.log(\"type2: \", type),\n            console.log(\"options2: \", options),\n            console.log(\"SlideValue2:\", slideValue),\n            \n                <Container >\n                    <div style={{textAlign: \"center\", fontFamily: \"sans-serif\", alignItems: \"center\", paddingBottom: \"5%\", color: \"blue\", fontSize: \"25px\"}}>\n                      <p className=\"blink\"> Sort Visualizer</p>\n                    </div>\n                <div>\n                    <div style={{height: 300, display: \"inline-flex\", paddingLeft: \"20%\"}}>\n                    <Slider\n                        defaultValue={slideValue}\n                        vertical \n                        progress\n                        min = {0}\n                        max = {maxValue}\n                        onChange = {this.handleSliderEvent}\n                    />                    \n                    </div>\n                    <div style={{display: \"inline-flex\",  position: \"relative\", width: \"50%\", height:\"40%\", paddingLeft: \"10%\"}}>\n                        <Bar \n                        type = {type}\n                        options={options}\n                        data = {data} \n                        redraw\n                        />\n                    </div> \n                </div>\n                \n                <div style={{paddingLeft: \"30%\", paddingTop: 30, width: \"100%\"}}>\n                    <div style={{display: \"inline-flex\", width: \"15%\"}}>\n                        <button onClick={this.mergeSort}>Merge Sort</button>\n                    </div>\n                    <div style={{display: \"inline-flex\", width: \"15%\"}}>\n                        <button onClick={this.ClickQuickSort}>Quick Sort</button>\n                    </div>\n                    <div style={{display: \"inline-flex\", width: \"15%\"}}>\n                        <button onClick={this.ClickBubbleSort}>Bubble Sort</button>\n                    </div>\n                    <div style={{display: \"inline-flex\", width: \"15%\"}}>\n                        <button onClick={this.ClickHeapSort}>Heap Sort</button>\n                    </div>\n                </div>\n                \n                </Container>\n\n        );\n      }\n    }\n\nexport default Home;\n","import React from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport Home from './Home';\n\nfunction App() {\n  return (\n    <div style={{paddingLeft: \"5%\", paddingTop: \"5%\"}}>\n        <Home />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}